/*
내 생각

1이 Memo 되있는지 확인
O -> continue
X -> 다음 줄

1보다 작은 숫자중 가장 큰 숫자를 빼면서, 1을 만들 수 있는지 확인
O -> Memo 에 저장 후 continue
X -> 출력

----------------------------------------
7
3 1 6 2 7 30 1
1 1 2 3 6 7 30
21
왜 이 예제를 줬을까 생각 해봐야함.
----------------------------------------
다 쓸수 있다 => 	10
1 2 3 4 5 6 7 8 9 10

8
1 1 1 1 1 1 1 2

무조건 Sum +1
-----------------------------------------------------------------------------
다 쓸수 없다 => 왜? 하나(다른게)가 너무 커서;;...
1 1 2 3 6 7 30 이라 할 경우, 이 떄 어떤 것이 결정 되는가? (Key point)
작은 것 합이 20이다. 답은 21이고, 현재 가지고 있는것은 1,1,2,3,6,7 이고 4,5, ... 19 까지는 없다.
이것이 있음을 증명해 보이면 된다.

s= 1  < aList[0] =>  답 1 // s+=1   // 1까진 측정가능  1
s= 2  < aList[1] =>  답 2 // s+=1   // 2까진 측정가능  1,1
s= 3  < aList[2] =>  답 3 // s+=2   // 4까진 측정가능  1,1,2
s= 5  < aList[3] =>  답 5 // s+=3   // 7까진 측정가능  1,1,2,3
s= 8  < aList[4] =>  답 8 // s+=6   // 13까진 측정가능 1,1,2,3,6
s= 14 < aList[5] =>  답 14 // s+=7  // 20까진 측정 가능
s= 21 < aList[6] =>  답 21  끝

숫자 13을 만들었다는건 1~12는 다 만들 수 있다는 이야기다.
전의 행동에서 7까지 만드는건 가능했으므로, 7까지 만드는 것이 가능한
숫자들에다가 6을 다 더하면 8,9,10,11,12,13 을 만드는게 가능하다는 것이 증명된다.

숫자 M 을 만들었다는건 1~M-1까지 다 만들 수 있다는 이야기다.
전의 행동에서 N(N < M)까지 만드는게 가능했으므로, N까지 만드는 것이 가능한
숫자들에다가 aList[i]을 다 더하면 N+1,N+2,...M-1,M 을 만드는게 가능하다는 것이
증명된다.

int ans = 1;
for (int i = 0; i < cnt; i++){
    if (ans < aList[i]){
        cout << ans << endl;
        return 0;
    }
    else ans += aList[i];
}
cout << ans << endl;

*/

#pragma warning(disable:4996)
#include <iostream>
#include <stdio.h>
#include <algorithm>
using namespace std;

int cnt;
int aList[1001];

int main(){
	scanf("%d", &cnt);
	for (int i = 0; i < cnt; i++){
		scanf("%d", &aList[i]);
	}
	sort(aList, aList+cnt);
	int ans = 1;
	for (int i = 0; i < cnt; i++){
		if (ans < aList[i]){
			cout << ans << endl;
			return 0;
		}
		else ans += aList[i];
	}
	cout << ans << endl;
	return 0;
}